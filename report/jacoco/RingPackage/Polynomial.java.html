<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Polynomial.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sparse</a> &gt; <a href="index.source.html" class="el_package">RingPackage</a> &gt; <span class="el_source">Polynomial.java</span></div><h1>Polynomial.java</h1><pre class="source lang-java linenums">package RingPackage;

import java.util.ArrayList;
import java.util.List;
import java.util.ListIterator;
import java.util.Objects;

/**t
 * @author Vidyut Veedgav
 * a class representing a polynomial ring, meant to emulate functionality for polynomials
 */
<span class="fc" id="L12">public final class Polynomial&lt;T&gt; {</span>
    
    private final List&lt;T&gt; coefficients; //a private instance field representing the polynomial's coefficients

    /**
     * a constructor for the Polynomial class
     * sets the coefficients p0, p1, ..., pm
     * @param coefficients
     */
<span class="fc" id="L21">    private Polynomial(List&lt;T&gt; coefficients) {</span>
        //null check
<span class="pc bpc" id="L23" title="1 of 2 branches missed.">        assert coefficients != null : &quot;coefficients cannot be null&quot;;</span>
<span class="fc" id="L24">        this.coefficients = coefficients;</span>
<span class="fc" id="L25">    }</span>

    /**
     * a method to return a new polynomial created from an immutable copy of the input list
     * @param &lt;S&gt;
     * @param coefficients
     * @return a new polynomial
     */
    public static final &lt;S&gt; Polynomial&lt;S&gt; from(List&lt;S&gt; coefficients) {
        //null check
<span class="fc" id="L35">        Objects.requireNonNull(coefficients, &quot;coefficients cannot be null&quot;);</span>

<span class="fc" id="L37">        return new Polynomial&lt;&gt;(List.copyOf(coefficients)); </span>
    }

    /**
     * a getter method to return a mutable copy of the coefficients
     * @return a mutable list of coefficients
     */
    public List&lt;T&gt; getCoefficients() {
<span class="fc" id="L45">        return new ArrayList&lt;&gt;(coefficients);</span>
    }

    /**
     * overrides the toString method to print the polynomial's coefficients
     */
    @Override
    public String toString() {
<span class="nc" id="L53">        return &quot;Polynomial [coefficients=&quot; + coefficients + &quot;]&quot;;</span>
    }

    /**
     * a method to add two polynomials together
     * Example:
     * a: (1, 2, 3)
     * b: (4, 5, 6)
     * a + b = (5, 7, 9)
     * McCabe's Complexity: 3
     * @param other
     * @param ring
     * @return the sum
     */
    public Polynomial&lt;T&gt; plus(Polynomial&lt;T&gt; other, Ring&lt;T&gt; ring) {

        //null checks
<span class="fc" id="L70">        Objects.requireNonNull(other, &quot;the 'other' parameter cannot be null&quot;);</span>
<span class="fc" id="L71">        Objects.requireNonNull(ring, &quot;the 'ring' parameter cannot be null&quot;);</span>

<span class="fc" id="L73">        List&lt;T&gt; a = this.getCoefficients(); //coefficients of the first polynomial</span>
<span class="fc" id="L74">        List&lt;T&gt; b = other.getCoefficients(); //coefficients of the second polynomial</span>

<span class="fc" id="L76">        int maxLength = Math.max(a.size(), b.size()); //computing the length of the longer list</span>
<span class="fc" id="L77">        List&lt;T&gt; sum_list = new ArrayList&lt;&gt;(maxLength); //a new list storing the sum values</span>

        //initializing the iterators
<span class="fc" id="L80">        ListIterator&lt;T&gt; aIter = a.listIterator();</span>
<span class="fc" id="L81">        ListIterator&lt;T&gt; bIter = b.listIterator();</span>

        //iterating until the longer list's index is reached
<span class="pc bpc" id="L84" title="1 of 4 branches missed.">        while (aIter.hasNext() || bIter.hasNext()) { </span>

            //  for each of the lists, checks if the end of the list is reached, 
            //  and either assigns the addend to the coefficient at the index or zero
<span class="fc" id="L88">            T a_addend = getAddend(ring, a, aIter); </span>
<span class="fc" id="L89">            T b_addend = getAddend(ring, b, bIter);</span>

<span class="fc" id="L91">            T sum = ring.sum(a_addend, b_addend); //computes the sum of the addends</span>
<span class="fc" id="L92">            sum_list.add(sum); //adds the sum to the sum_list, which will be used to create the returned polynomial</span>
<span class="fc" id="L93">        }</span>
<span class="fc" id="L94">        return new Polynomial&lt;&gt;(sum_list);</span>
    }

    /**
     *  a helper method for the plus method to assign determine if an addend should be assigned to a value or zero
     * @param ring
     * @param list
     * @param aIter
     * @param i
     * @return the assignemnt given the condition
     */
    private T getAddend(Ring&lt;T&gt; ring, List&lt;T&gt; list, ListIterator&lt;T&gt; iterator) {

<span class="pc bpc" id="L107" title="1 of 2 branches missed.">        assert ring != null : &quot;ring cannot be null&quot;;</span>
<span class="pc bpc" id="L108" title="1 of 2 branches missed.">        assert list != null : &quot;list cannot be null&quot;;</span>
<span class="pc bpc" id="L109" title="1 of 2 branches missed.">        assert iterator != null : &quot;iterator cannot be null&quot;;</span>
<span class="pc bpc" id="L110" title="1 of 2 branches missed.">        return (iterator.hasNext()) ? iterator.next() : ring.zero();</span>
    }

    /**
     * a method to multiply two polynomials together
     * Example:
     * a: (1, 2, 3)
     * b: (4, 5, 6)
     * a * b = (1 * 4),
     *         ((1 * 5) + (2 * 4)),
     *         ((1 * 6) + (2 * 5) + (3 * 4)),
     *         ((1 * 0) + (2 * 6) + (3 * 5) + (0 * 4)),
     *         ((1 * 0) + (2 * 0), (3 * 6) + (0 * 5) + (0 * 4))
     * 
     *       = (4, 13, 28, 27, 18)
     * McCabe's Complexity: 3
     * @param other
     * @param ring
     * @return the product
     */
    public Polynomial&lt;T&gt; times(Polynomial&lt;T&gt; other, Ring&lt;T&gt; ring) {

        //null checks
<span class="fc" id="L133">        Objects.requireNonNull(other, &quot;the 'other' parameter cannot be null&quot;);</span>
<span class="fc" id="L134">        Objects.requireNonNull(ring, &quot;the 'ring' parameter cannot be null&quot;); </span>
        
<span class="fc" id="L136">        List&lt;T&gt; a = this.getCoefficients(); //coefficients of the first polynomial </span>
<span class="fc" id="L137">        List&lt;T&gt; b = other.getCoefficients(); //coefficients of the second polynomial</span>

<span class="fc" id="L139">        int productLength = computeProductLength(a, b);      //  edge case: if both lists are empty, product length will be 0                                                  //        if not, the </span>
                                                             //  otherwise, it will be (size of a + size of b - 1)
<span class="fc" id="L141">        List&lt;T&gt; product_list = new ArrayList&lt;&gt;(productLength); //creates the list of products that will be used to create the final polynomial</span>

<span class="fc" id="L143">        ListIterator&lt;T&gt; aIter = a.listIterator(); //iterator for list a </span>
<span class="fc" id="L144">        ListIterator&lt;T&gt; bIter = b.listIterator(); //iterator for list b</span>

<span class="fc" id="L146">        int a_start = 0; //start index of list a</span>

        //iterates until productLength is reached
<span class="fc bfc" id="L149" title="All 2 branches covered.">        for (int i = 0; i &lt; productLength; i++) {</span>

<span class="fc" id="L151">            T product = ring.zero(); //initializing the product to zero</span>
<span class="fc" id="L152">            a_start = computeStartIndex(i, a_start, b); //adjusting the start index of a depending on whether b has more elements</span>

            //initializing the iterators to their respective start indices
<span class="fc" id="L155">            aIter = a.listIterator(a_start);</span>
<span class="fc" id="L156">            bIter = b.listIterator(Math.min(i + 1, b.size()));</span>

            //iterates while aIter has a next element and bIter has a previous element
<span class="fc bfc" id="L159" title="All 4 branches covered.">            while (aIter.hasNext() &amp;&amp; bIter.hasPrevious()) {</span>
<span class="fc" id="L160">                T a_factor = aIter.next(); //defining a's next value as the first factor</span>
<span class="fc" id="L161">                T b_factor = bIter.previous(); //defining b's previous value as second factor</span>
<span class="fc" id="L162">                T result = ring.product(a_factor, b_factor); //multiplies the factors</span>
<span class="fc" id="L163">                product = ring.sum(product, result); //sums the result of the multiplication with the previous result</span>
<span class="fc" id="L164">            }</span>
<span class="fc" id="L165">            product_list.add(product); //adds the product to the list of products</span>
        }        
<span class="fc" id="L167">       return new Polynomial&lt;&gt;(product_list); </span>
    }

    /**
     * a helper method to compute whether an index should be incremented in the times method
     * @param args
     */
    private int computeStartIndex(int currentIndex, int startIndex, List&lt;T&gt; list) {
        //null check
<span class="pc bpc" id="L176" title="1 of 2 branches missed.">        assert list != null : &quot;list cannot be null&quot;;</span>

<span class="fc bfc" id="L178" title="All 2 branches covered.">        if ((currentIndex + 1) &gt; list.size()) {</span>
<span class="fc" id="L179">            startIndex = startIndex + 1;</span>
        }
<span class="fc" id="L181">        return startIndex;</span>
    }

    /**
     * a helper method to handle the edge case where both polynomials have no coefficients in the times method
     * avoids an OutOfBoundsException
     * @param args
     */
    private int computeProductLength(List&lt;T&gt; a, List&lt;T&gt; b) {

        //null checks
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">        assert a != null : &quot;a cannot be null&quot;;</span>
<span class="pc bpc" id="L193" title="1 of 2 branches missed.">        assert b != null : &quot;b cannot be null&quot;;</span>

<span class="pc bpc" id="L195" title="3 of 4 branches missed.">        if (a.isEmpty() &amp;&amp; b.isEmpty()) {</span>
<span class="nc" id="L196">            return 0;</span>
        }
<span class="fc" id="L198">        return a.size() + b.size() - 1;</span>
    }

    public static void main(String[] args) {
        
<span class="nc" id="L203">        Polynomial&lt;Integer&gt; poly1 = Polynomial.from(List.of(1, 0, -13, -12));</span>
<span class="nc" id="L204">        Polynomial&lt;Integer&gt; poly2 = Polynomial.from(List.of(1, -10));</span>
        
<span class="nc" id="L206">        IntegerRing intRing = new IntegerRing();</span>
<span class="nc" id="L207">        Ring&lt;Polynomial&lt;Integer&gt;&gt; polyRing = PolynomialRing.instance(intRing);</span>
<span class="nc" id="L208">        System.out.println(poly1.times(poly2, intRing));</span>

<span class="nc" id="L210">        List&lt;Polynomial&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(List.of(poly1, poly2)); </span>
<span class="nc" id="L211">        System.out.println(Rings.product(list, polyRing));</span>
<span class="nc" id="L212">    }</span>
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>