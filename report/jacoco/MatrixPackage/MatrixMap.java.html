<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MatrixMap.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sparse</a> &gt; <a href="index.source.html" class="el_package">MatrixPackage</a> &gt; <span class="el_source">MatrixMap.java</span></div><h1>MatrixMap.java</h1><pre class="source lang-java linenums">package MatrixPackage;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Scanner;
import java.util.function.BinaryOperator;
import java.util.function.Function;
import java.util.stream.Collectors;

import MatrixPackage.MatrixMap.InvalidLengthException.Cause;
import RingPackage.IntegerRing;
import RingPackage.Ring;
import RingPackage.Rings;

/**
 * @author Vidyut Veedgav
 * a class representing a matrix map class
 */
<span class="fc" id="L23">public final class MatrixMap&lt;T&gt; implements Matrix&lt;T&gt; { </span>
    
    private final Map&lt;Indexes, T&gt;  matrix; //a field representing the matrix
    private final Indexes size;
    
    /**
     * a constructor for the matrix
     * @param matrix
     */
<span class="fc" id="L32">    private MatrixMap(Map&lt;Indexes, T&gt; matrix) {</span>

        //null check
<span class="pc bpc" id="L35" title="1 of 2 branches missed.">        assert matrix != null : &quot;matrix cannot be null&quot;;</span>
<span class="fc" id="L36">        this.matrix = matrix;</span>
<span class="fc" id="L37">        this.size = Collections.max(matrix.keySet());</span>
<span class="fc" id="L38">    }</span>

    /**
     * a getter method for the map used for testing
     * @return an immutable copy of the matrix, which can be used for containment testing
     */
    protected Map&lt;Indexes, T&gt; getMap() {
<span class="fc" id="L45">        return Map.copyOf(matrix);</span>
    }

    /**
     * a getter method for the map used for testing
     * @return a mutable copy of the matrix, which can be used for containment testing
     */
    protected Map&lt;Indexes, T&gt; getModifiableMap() {
<span class="nc" id="L53">        return (matrix);</span>
    }

    /**
     * a method to return the matrix size by finding the greatest key in the keySet
     * @return
     */
    public Indexes size() {
<span class="fc" id="L61">        return size;</span>
    }

    /**
     * a method to override the toString method
     */
    @Override
    public String toString() {

<span class="fc" id="L70">        Indexes size = size();</span>
<span class="fc" id="L71">        int numRows = size.row() + 1; // Add 1 to include row 0</span>
<span class="fc" id="L72">        int numCols = size.column() + 1; // Add 1 to include column 0</span>
    
<span class="fc" id="L74">        StringBuilder sb = new StringBuilder();</span>
        //indexing through the rows
<span class="fc bfc" id="L76" title="All 2 branches covered.">        for (int row = 0; row &lt; numRows; row++) {</span>

            //indexing through the corresponding column
<span class="fc bfc" id="L79" title="All 2 branches covered.">            for (int col = 0; col &lt; numCols; col++) {</span>
<span class="fc" id="L80">                addEntry(sb, row, col);</span>
            }
<span class="fc" id="L82">            sb.append(&quot;\n&quot;); //add a carriage return</span>
        }
<span class="fc" id="L84">        return sb.toString();</span>
    }

    /**
     * a subroutine of the toString method which creates appends a String entry to the matrix
     * @param sb
     * @param row
     * @param col
     */
    private void addEntry(StringBuilder sb, int row, int col) {

        //null check
<span class="pc bpc" id="L96" title="1 of 2 branches missed.">        assert sb != null : &quot;sb cannot be null&quot;;</span>

<span class="fc" id="L98">        Indexes index = new Indexes(row, col); //creating an index</span>
<span class="fc" id="L99">        T value = value(index); //finding the value at this index</span>

<span class="fc" id="L101">        sb.append(&quot;[&quot;).append(index.toString()).append(&quot;]: &quot;).append(value).append(&quot;\t&quot;); //add the entry</span>
<span class="fc" id="L102">    }</span>

    /**
     * a method to return the element at the given indexes
     * FOUNDATION METHOD FOR OTHER TWO VALUE METHODS
     * @return the corresponding value
     */
    public T value(Indexes indexes) {

        //null check
<span class="fc" id="L112">        Objects.requireNonNull(indexes, &quot;indexes cannot be null&quot;);</span>
<span class="fc" id="L113">        return matrix.get(indexes);</span>
    }

    /**
     * overloading the value method to account for unique indexes
     * @return the corresponding value
     */
    public T value(int row, int column) {
<span class="fc" id="L121">        return value(new Indexes(row, column));</span>
    }
    
    /**
     * a nested class to aid error handling by defining protocols for controlling the matrix lengths
     */
    static class InvalidLengthException extends Exception {

        /**
         * an enum to define the possible values of the exception's cause
         */
<span class="fc" id="L132">        enum Cause {</span>
<span class="fc" id="L133">            ROW, </span>
<span class="fc" id="L134">            COLUMN</span>
        }
    
        private Cause cause; //a private variable declaring the cause
        private Integer length; //a private variable declaring the length

        /**
         * a constructor for the InvalidLengthException
         * @param cause
         * @param length
         */
<span class="fc" id="L145">        public InvalidLengthException(Cause cause, Integer length) {</span>

            //null checks
<span class="fc" id="L148">            Objects.requireNonNull(cause);</span>
<span class="fc" id="L149">            Objects.requireNonNull(length);</span>

<span class="fc" id="L151">            this.cause = cause;</span>
<span class="fc" id="L152">            this.length = length;</span>
<span class="fc" id="L153">        }</span>

        /**
         * getter for the cause
         * @return the cause
         */
        public Cause cause() {
<span class="fc" id="L160">            return cause;</span>
        }

        /**
         * a getter for the length
         * @return the length
         */
        public Integer length() {
<span class="fc" id="L168">            return length;</span>
        }

        /**
         * a method to check if the length is positive and throw an exception otherwise
         * @param cause
         * @param length
         * @return the length
         */
        public static int requireNonEmpty(Cause cause, int length) {

            //null check
<span class="fc" id="L180">            Objects.requireNonNull(cause, &quot;cause cannot be null&quot;);</span>

            //checks if the length of the cause dimention fails the valid criteria
<span class="pc bpc" id="L183" title="1 of 2 branches missed.">            if (length &lt;= 0) {</span>
<span class="nc" id="L184">                throw new IllegalArgumentException(new InvalidLengthException(cause, length)); </span>
            }
<span class="fc" id="L186">            return length;</span>
        }
    }

    /**
     * a method to create an instance of a MatrixMap using a defined valueMapper function
     * THE FOUNDATIONAL METHOD FOR CREATING MATRIX INSTANCES
     * @param &lt;S&gt;
     * @param rows
     * @param columns
     * @param valueMapper
     * @return a new MatrixMap
     */
    public static &lt;S&gt; MatrixMap&lt;S&gt; instance(int rows, int columns, Function&lt;Indexes, S&gt; valueMapper) {

        //error handling
<span class="fc" id="L202">        Objects.requireNonNull(valueMapper, &quot;valueMapper cannot be null&quot;);</span>
<span class="fc" id="L203">        InvalidLengthException.requireNonEmpty(Cause.ROW, rows); //checks if the rows are valid</span>
<span class="fc" id="L204">        InvalidLengthException.requireNonEmpty(Cause.COLUMN, columns); //checks if the columns are valid</span>

<span class="fc" id="L206">        Map&lt;Indexes, S&gt; matrix = new HashMap&lt;&gt;(); //creating the map</span>
<span class="fc" id="L207">        List&lt;Indexes&gt; indexes = Indexes.stream(rows, columns).collect(Collectors.toList()); //creating a list of indexes</span>

<span class="fc" id="L209">        populate(valueMapper, matrix, indexes); //populating the matrix with the specified values</span>
<span class="fc" id="L210">        return new MatrixMap&lt;&gt;(Map.copyOf(matrix));</span>
    }

    /**
     * a subroutine of the instance method which fills the matrix with the specified elements
     * @param &lt;S&gt;
     * @param valueMapper
     * @param matrix
     * @param indexes
     */
    private static &lt;S&gt; void populate(Function&lt;Indexes, S&gt; valueMapper, Map&lt;Indexes, S&gt; matrix, List&lt;Indexes&gt; indexes) {

        //null checks
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">        assert valueMapper != null : &quot;valueMapper cannot be null&quot;;</span>
<span class="pc bpc" id="L224" title="1 of 2 branches missed.">        assert matrix != null : &quot;matrix cannot be null&quot;;</span>
<span class="pc bpc" id="L225" title="1 of 2 branches missed.">        assert indexes != null : &quot;indexes cannot be null&quot;;</span>

<span class="fc bfc" id="L227" title="All 2 branches covered.">        for (Indexes index : indexes) {</span>
<span class="fc" id="L228">            S value = valueMapper.apply(index);</span>
<span class="fc" id="L229">            matrix.put(index, value);</span>
<span class="fc" id="L230">        }</span>
<span class="fc" id="L231">    }</span>

    /**
     * overloading the instance method to accept an Indexes object as a parameter
     * @param &lt;S&gt;
     * @param size
     * @param valueMapper
     * @return a MatrixMap
     */
    public static &lt;S&gt; MatrixMap&lt;S&gt; instance(Indexes size, Function&lt;Indexes, S&gt; valueMapper) {

        //null checks
<span class="fc" id="L243">        Objects.requireNonNull(size, &quot;size cannot be null&quot;);</span>
<span class="fc" id="L244">        Objects.requireNonNull(valueMapper, &quot;valueMapper cannot be null&quot;);</span>
    
        //calling the foundational instance method
<span class="fc" id="L247">        return MatrixMap.instance(size.row(), size.column(), valueMapper);</span>
    }

    /**
     * a method to populate a MatrixMap using constant values
     * @param &lt;S&gt;
     * @param size
     * @param value
     * @return a new MatrixMap
     */
    public static &lt;S&gt; MatrixMap&lt;S&gt; constant(int size, S value) {

        //null check
<span class="fc" id="L260">        Objects.requireNonNull(value, &quot;value cannot be null&quot;);</span>

        //calling the foundational instance method
<span class="fc" id="L263">        return instance(size, size, (index) -&gt; value);</span>
    }

    /**
     * a method to return a new square matrix populated with the identity along the diagonal and zero otherwise
     * @param &lt;S&gt;
     * @param size
     * @param zero
     * @param identity
     * @return a new MatrixMap
     */
    public static &lt;S&gt; MatrixMap&lt;S&gt; identity(int size, S zero, S identity) {

        //null checks
<span class="fc" id="L277">        Objects.requireNonNull(zero, &quot;zero cannot be null&quot;);</span>
<span class="fc" id="L278">        Objects.requireNonNull(identity, &quot;identity cannot be null&quot;);</span>

        //calling the foundational instance method
<span class="fc bfc" id="L281" title="All 2 branches covered.">        return instance(size, size, (index) -&gt; (index.areDiagonal()) ? identity : zero);</span>
    }

    /**
     * a method to populate a MatrixMap instance from the values in the two-dimentional matrix
     * @param &lt;S&gt;
     * @param matrix
     * @return a new MatrixMap
     */
    public static &lt;S&gt; MatrixMap&lt;S&gt; from(S[][] matrix) {

        //null check
<span class="fc" id="L293">        Objects.requireNonNull(matrix, &quot;matrix cannot be null&quot;);</span>

        //calling the foundational instance method
<span class="fc" id="L296">        return instance(matrix.length - 1, matrix[0].length - 1, (index) -&gt; index.value(matrix));</span>
    }

    /**
     * a nested class to aid error handling
     */
    static class InconsistentSizeException extends Exception {

        private Indexes thisIndex; //stores the current Index
        private Indexes otherIndex; //stores the other Index

        /**
         * constructor
         * @param thisIndex
         * @param otherIndex
         */
<span class="nc" id="L312">        public InconsistentSizeException(Indexes thisIndex, Indexes otherIndex) {</span>

            //null checks
<span class="nc" id="L315">            Objects.requireNonNull(thisIndex, &quot;thisIndex cannot be null&quot;);</span>
<span class="nc" id="L316">            Objects.requireNonNull(otherIndex, &quot;otherIndex cannot be null&quot;);</span>

<span class="nc" id="L318">            this.thisIndex = thisIndex;</span>
<span class="nc" id="L319">            this.otherIndex = otherIndex;</span>
<span class="nc" id="L320">        }</span>

        /**
         * getter for the thisIndex field
         * @return
         */
        public Indexes getThisIndex() {
<span class="nc" id="L327">            return thisIndex;</span>
        }

        /**
         * a getter for the otherIndex field
         * @return
         */
        public Indexes getOtherIndex() {
<span class="nc" id="L335">            return otherIndex;</span>
        }

        /**
         * a method which checks if two matrixes are the same size
         * @param &lt;T&gt;
         * @param thisMatrix
         * @param otherMatrix
         * @return
         * @throws IllegalArgumentException
         */
        public static &lt;T&gt; Indexes requireMatchingSize(Matrix&lt;T&gt; thisMatrix, Matrix&lt;T&gt; otherMatrix) {

            //null checks
<span class="fc" id="L349">            Objects.requireNonNull(thisMatrix, &quot;thisMatrix cannot be null&quot;);</span>
<span class="fc" id="L350">            Objects.requireNonNull(otherMatrix, &quot;otherMatrix cannot be null&quot;);</span>
            
            //checks if the sizes are not equal
<span class="pc bpc" id="L353" title="1 of 2 branches missed.">            if (!thisMatrix.size().equals(otherMatrix.size())) {</span>
<span class="nc" id="L354">                throw new IllegalArgumentException(new InconsistentSizeException(thisMatrix.size(), otherMatrix.size()));</span>
            }
<span class="fc" id="L356">            return thisMatrix.size();</span>
        }
    }

    /**s
     * a nested class used to check if a matrix is a square
     */

    static class NonSquareException extends Exception {

        private final Indexes indexes; //instance field storing the index to be checked

        /**
         * constructor
         * @param indexes
         */
<span class="nc" id="L372">        public NonSquareException(Indexes indexes) {</span>

            //null check
<span class="nc" id="L375">            Objects.requireNonNull(indexes, &quot;indexes cannot be null&quot;);</span>
<span class="nc" id="L376">            this.indexes = indexes;</span>
<span class="nc" id="L377">        }</span>

        /**
         * a getter for the indexes method
         * @return
         */
        public Indexes getIndexes() {
<span class="nc" id="L384">            return indexes;</span>
        }

        /**
         * a method to throw an exception if the index that is passed in is not on the diagonal of the matrix
         * @param indexes should be the size of the matrix
         * @return
         */
        public static Indexes requireDiagonal(Indexes indexes) {

            //null check
<span class="fc" id="L395">            Objects.requireNonNull(indexes, &quot;indexes cannot be null&quot;);</span>

            //checks if the index is on the diagonal
<span class="pc bpc" id="L398" title="1 of 2 branches missed.">            if (!indexes.areDiagonal()) {</span>
<span class="nc" id="L399">                throw new IllegalStateException(new NonSquareException(indexes));</span>
            }
<span class="fc" id="L401">            return indexes;</span>
        }
    }

    /**
     * a method to support matrix addition
     * @param other
     * @param plus
     * @return
     */
    public MatrixMap&lt;T&gt; plus(Matrix&lt;T&gt; other, BinaryOperator&lt;T&gt; plus) {

        //null checks
<span class="fc" id="L414">        Objects.requireNonNull(other, &quot;other cannot be null&quot;);</span>
<span class="fc" id="L415">        Objects.requireNonNull(plus, &quot;plus cannot be null&quot;);</span>

        //checking if the matrixes are the same size
<span class="fc" id="L418">        InconsistentSizeException.requireMatchingSize(this, other); </span>

<span class="fc" id="L420">        return instance(this.size(), (index) -&gt; plus.apply(this.value(index), other.value(index))); //creating a new instance of the matrix containing the sum</span>
    }

    /**
     * a method to support matrix multiplication
     * @return
     */
    public MatrixMap&lt;T&gt; times(Matrix&lt;T&gt; other, Ring&lt;T&gt; ring) {

        //null checks
<span class="fc" id="L430">        Objects.requireNonNull(other, &quot;other cannot be null&quot;);</span>
<span class="fc" id="L431">        Objects.requireNonNull(ring, &quot;ring cannot be null&quot;);</span>

<span class="fc" id="L433">        NonSquareException.requireDiagonal(this.size()); //checks if this matrix is a square</span>
<span class="fc" id="L434">        NonSquareException.requireDiagonal(other.size()); //checks if the other matrix is a square</span>
<span class="fc" id="L435">        InconsistentSizeException.requireMatchingSize(this, other); //checks if the matrixes are of equal size</span>

<span class="fc" id="L437">        int length = this.size().row(); //sets the length of the matrixes by accessing the row of the size of this index (can be row or column from either matrix)</span>
<span class="fc" id="L438">        return instance(this.size(), (index) -&gt; { //creates an instance of a matrix containing the product</span>

<span class="fc" id="L440">            List&lt;T&gt; products = new ArrayList&lt;&gt;();</span>
            //indexes until length is reached and adds to the product list the element at the row of this and column of other
<span class="fc bfc" id="L442" title="All 2 branches covered.">            for (int i = 0; i &lt;= length; i++) {</span>
<span class="fc" id="L443">                products.add(ring.product(this.value(new Indexes(index.row(), i)), other.value(new Indexes(i, index.column()))));</span>
            }
<span class="fc" id="L445">            return Rings.sum(products, ring); //sums the elements of the product list</span>
        });
    }

    /**
     * a method to convert this matrix to a sparse matrix
     * @return
     */
    public SparseMatrixMap&lt;T&gt; convertToSparse() {
<span class="nc" id="L454">        return SparseMatrixMap.instance(this.size(), (index) -&gt; this.value(index));</span>
    }

    public static void main(String[] args) {

<span class="nc" id="L459">        Scanner input = new Scanner(System.in);</span>
<span class="nc" id="L460">        System.out.println(&quot;Enter Matrix Size&quot;);</span>
<span class="nc" id="L461">        Integer size = Integer.valueOf(input.nextLine());</span>
<span class="nc" id="L462">        System.out.println(&quot;SIZE = &quot; + size);</span>
     
<span class="nc" id="L464">        System.out.println(&quot;Matrix One Values:&quot;);</span>
<span class="nc" id="L465">        Map&lt;Indexes, Integer&gt; indexMap = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">        for (int i = 0; i &lt;= size; i++) {</span>
<span class="nc bnc" id="L467" title="All 2 branches missed.">            for (int j = 0; j &lt;= size; j++) {</span>
<span class="nc" id="L468">                Indexes index = new Indexes(i, j);</span>
<span class="nc" id="L469">                System.out.println(&quot;Value at: &quot; + index.toString());</span>
<span class="nc" id="L470">                indexMap.put(index, Integer.valueOf(input.nextLine()));</span>
            }
        }
<span class="nc" id="L473">        MatrixMap&lt;Integer&gt; m1 = MatrixMap.instance(new Indexes(size, size), (index) -&gt; indexMap.get(index));</span>
<span class="nc" id="L474">        System.out.println(&quot;MATRIX 1: &quot;);</span>
<span class="nc" id="L475">        System.out.println(m1.toString());</span>

<span class="nc" id="L477">        System.out.println(&quot;Matrix Two Values:&quot;);</span>
<span class="nc" id="L478">        Map&lt;Indexes, Integer&gt; indexMap2 = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L479" title="All 2 branches missed.">        for (int i = 0; i &lt;= size; i++) {</span>
<span class="nc bnc" id="L480" title="All 2 branches missed.">            for (int j = 0; j &lt;= size; j++) {</span>
<span class="nc" id="L481">                Indexes index = new Indexes(i, j);</span>
<span class="nc" id="L482">                System.out.println(&quot;Value at: &quot; + index.toString());</span>
<span class="nc" id="L483">                indexMap2.put(index, Integer.valueOf(input.nextLine()));</span>
            }
        }
<span class="nc" id="L486">        MatrixMap&lt;Integer&gt; m2 = MatrixMap.instance(new Indexes(size, size), (index) -&gt; indexMap2.get(index));</span>
<span class="nc" id="L487">        System.out.println(&quot;MATRIX 1: &quot;);</span>
<span class="nc" id="L488">        System.out.println(m1.toString());</span>

<span class="nc" id="L490">        System.out.println(&quot;ADD or MULTIPLY ([A/M])&quot;);</span>
<span class="nc" id="L491">        String addOrMultiply = input.nextLine();</span>

<span class="nc" id="L493">        input.close();</span>

<span class="nc" id="L495">        Ring&lt;Integer&gt; intRing = new IntegerRing();</span>

<span class="nc bnc" id="L497" title="All 2 branches missed.">        if (addOrMultiply.equals(&quot;A&quot;)) {</span>
<span class="nc" id="L498">            MatrixMap&lt;Integer&gt; sum = m1.plus(m2, (x, y) -&gt; intRing.sum(x, y));</span>
<span class="nc" id="L499">            System.out.println(sum);</span>
<span class="nc" id="L500">        }</span>
<span class="nc bnc" id="L501" title="All 2 branches missed.">        else if (addOrMultiply.equals(&quot;M&quot;)) {</span>
<span class="nc" id="L502">            MatrixMap&lt;Integer&gt; product = m1.times(m2, intRing);</span>
<span class="nc" id="L503">            System.out.println(product);</span>
<span class="nc" id="L504">        }</span>
        else {
<span class="nc" id="L506">            System.out.println(&quot;Invalid selection&quot;);</span>
        }
        
<span class="nc" id="L509">    }  </span>
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>