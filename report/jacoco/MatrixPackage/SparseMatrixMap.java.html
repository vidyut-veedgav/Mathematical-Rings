<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SparseMatrixMap.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sparse</a> &gt; <a href="index.source.html" class="el_package">MatrixPackage</a> &gt; <span class="el_source">SparseMatrixMap.java</span></div><h1>SparseMatrixMap.java</h1><pre class="source lang-java linenums">package MatrixPackage;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.function.BinaryOperator;
import java.util.function.Function;
import java.util.stream.Collectors;

import MatrixPackage.MatrixMap.InconsistentSizeException;
import MatrixPackage.MatrixMap.InvalidLengthException;
import MatrixPackage.MatrixMap.InvalidLengthException.Cause;
import MatrixPackage.MatrixMap.NonSquareException;
import RingPackage.IntegerRing;
import RingPackage.Ring;
import RingPackage.Rings;

public class SparseMatrixMap&lt;T&gt; implements Matrix&lt;T&gt; {

    private final Map&lt;Indexes, T&gt;  matrix; //a field representing the matrix
    private final Indexes size; //a field representing the size of the matrix
    private final Ring&lt;T&gt; ring; //a field representing a ring used for intermediate operations
    private final List&lt;Indexes&gt; nonZeroIndexes; //a field representing the indexes which are mapped to nonzero values

    /**
     * constructor
     */
<span class="fc" id="L34">    private SparseMatrixMap(Map&lt;Indexes, T&gt; matrix, Ring&lt;T&gt; ring) {</span>
<span class="fc" id="L35">        this.matrix = matrix;</span>
<span class="fc" id="L36">        this.size = Collections.max(matrix.keySet());</span>
<span class="fc" id="L37">        this.ring = ring;</span>
        
        //creates a list of the non zero indexes in the matrix
<span class="fc" id="L40">        nonZeroIndexes = matrix.keySet().stream()</span>
<span class="pc bpc" id="L41" title="1 of 2 branches missed.">                                .filter(key -&gt; !value(key).equals(ring.zero()))</span>
<span class="fc" id="L42">                                .collect(Collectors.toList());</span>
<span class="fc" id="L43">    }</span>

    /**
     * finds the intersection of nonzero indexes between this matrix and another
     * @param other
     * @return
     */
    private List&lt;Indexes&gt; intersectionNonZeroIndexes(SparseMatrixMap&lt;T&gt; other) {
<span class="nc" id="L51">        List&lt;Indexes&gt; intersection = new ArrayList&lt;&gt;(this.nonZeroIndexes);</span>
<span class="nc" id="L52">        intersection.retainAll(other.nonZeroIndexes);</span>
<span class="nc" id="L53">        return intersection;</span>
    }

    /**
     * finds the union of nonzero indexes between this matrix and another
     * @param other
     * @return
     */
    private List&lt;Indexes&gt; unionNonZeroIndexes(SparseMatrixMap&lt;T&gt; other) {
<span class="nc" id="L62">        Set&lt;Indexes&gt; resultSet = new HashSet&lt;&gt;(nonZeroIndexes);</span>
<span class="nc" id="L63">        resultSet.addAll(other.nonZeroIndexes);</span>
<span class="nc" id="L64">        return new ArrayList&lt;&gt;(resultSet);</span>
    }

    /**
     * a method to get the size of this SparseMatrixMap
     */
    @Override
    public Indexes size() {
<span class="fc" id="L72">        return size;</span>
    }

    /**
     * a method to return the value of this SparseMatrixMap at a particular index
     * OPTION 1: add ring param to the interface method
     * OPTION 2: overload value method
     */
    @Override
    public T value(Indexes index) {
        
        //null check
<span class="fc" id="L84">        Objects.requireNonNull(index, &quot;indexes cannot be null&quot;);</span>
<span class="fc" id="L85">        T value = matrix.get(index);</span>
<span class="fc bfc" id="L86" title="All 2 branches covered.">        return (value == null) ? ring.zero() : value;</span>
    }

    /**
     * a foundational instance method for the SparseMatrixMap
     * @param &lt;S&gt;
     * @param rows
     * @param columns
     * @param valueMapper
     * @return
     */
    public static &lt;S&gt; SparseMatrixMap&lt;S&gt; instance(int rows, int columns,  Ring&lt;S&gt; ring, Function&lt;Indexes, S&gt; valueMapper) {

<span class="fc" id="L99">        Objects.requireNonNull(valueMapper, &quot;valueMapper cannot be null&quot;);</span>
<span class="fc" id="L100">        InvalidLengthException.requireNonEmpty(Cause.ROW, rows); //checks if the rows are valid</span>
<span class="fc" id="L101">        InvalidLengthException.requireNonEmpty(Cause.COLUMN, columns); //checks if the columns are valid</span>

<span class="fc" id="L103">        Map&lt;Indexes, S&gt; matrix = new HashMap&lt;&gt;(); //creating the map</span>
<span class="fc" id="L104">        List&lt;Indexes&gt; indexes = Indexes.stream(rows, columns).collect(Collectors.toList()); //creating a list of indexes</span>

<span class="fc bfc" id="L106" title="All 2 branches covered.">        for (Indexes index : indexes) {</span>
<span class="fc" id="L107">            S value = valueMapper.apply(index);</span>
<span class="fc bfc" id="L108" title="All 2 branches covered.">            if (!value.equals(ring.zero())) {</span>
<span class="fc" id="L109">                matrix.put(index, value);</span>
            }
<span class="fc" id="L111">        }</span>
<span class="fc" id="L112">        return new SparseMatrixMap&lt;&gt;(Map.copyOf(matrix), ring);</span>
    }

    /**
     * overloading the instance method to accept an Indexes object as a parameter
     * @param &lt;S&gt;
     * @param size
     * @param valueMapper
     * @return a MatrixMap
     */
    public static &lt;S&gt; SparseMatrixMap&lt;S&gt; instance(Indexes size, Ring&lt;S&gt; ring, Function&lt;Indexes, S&gt; valueMapper) {

        //null checks
<span class="fc" id="L125">        Objects.requireNonNull(size, &quot;size cannot be null&quot;);</span>
<span class="fc" id="L126">        Objects.requireNonNull(valueMapper, &quot;valueMapper cannot be null&quot;);</span>
    
        //calling the foundational instance method
<span class="fc" id="L129">        return SparseMatrixMap.instance(size.row(), size.column(), ring, valueMapper);</span>
    }

    /**
     * a method to return a new sparse matrix populated with a constant non-zero value
     * @param &lt;S&gt;
     * @param size
     * @param value
     * @return
     */
    public static &lt;S&gt; SparseMatrixMap&lt;S&gt; constant(int size, Ring&lt;S&gt; ring, S value) {

        //null check
<span class="fc" id="L142">        Objects.requireNonNull(value, &quot;value cannot be null&quot;);</span>

        //TODO implement error handling to disallow calling this method with a value of 0

        //calling the foundational instance method
<span class="fc" id="L147">        return instance(size, size, ring, (index) -&gt; value);</span>
    }

    /**
     * a method to return a new square sparse matrix populated with the identity along the diagonal
     * @param &lt;S&gt;
     * @param size
     * @param zero
     * @param identity
     * @return a new MatrixMap
     */
    public static &lt;S&gt; SparseMatrixMap&lt;S&gt; identity(int size, Ring&lt;S&gt; ring) {

        //null checks
<span class="fc" id="L161">        Objects.requireNonNull(ring.zero(), &quot;zero cannot be null&quot;);</span>
<span class="fc" id="L162">        Objects.requireNonNull(ring.identity(), &quot;identity cannot be null&quot;);</span>

        //calling the foundational instance method
<span class="fc bfc" id="L165" title="All 2 branches covered.">        return instance(size, size, ring, (index) -&gt; (index.areDiagonal()) ? ring.identity() : ring.zero());</span>
    }


    /**
     * a method to add this matrix to another
     */
    @Override
    public Matrix&lt;T&gt; plus(Matrix&lt;T&gt; other, BinaryOperator&lt;T&gt; plus) {
        
        //null checks
<span class="nc" id="L176">        Objects.requireNonNull(other, &quot;other cannot be null&quot;);</span>
<span class="nc" id="L177">        Objects.requireNonNull(plus, &quot;plus cannot be null&quot;);</span>
        //consistent size checks
<span class="nc" id="L179">        InconsistentSizeException.requireMatchingSize(this, other); </span>

<span class="nc" id="L181">        return instance(this.size(), this.ring, (index) -&gt; plus.apply(this.value(index), other.value(index)));</span>
    }

    /**
     * a method to multiply this matrix with another
     * UNFINISHED, DON'T KNOW WHAT TO DO HERE LOLZ
     */

    //find intersection, for each value at intersection indexes, compute the product
    @Override
    public SparseMatrixMap&lt;T&gt; times(Matrix&lt;T&gt; other, Ring&lt;T&gt; ring) {
        
        //null checks
<span class="nc" id="L194">        Objects.requireNonNull(other, &quot;other cannot be null&quot;);</span>
<span class="nc" id="L195">        Objects.requireNonNull(ring, &quot;ring cannot be null&quot;);</span>

        //size checking
<span class="nc" id="L198">        NonSquareException.requireDiagonal(this.size()); //checks if this matrix is a square</span>
<span class="nc" id="L199">        NonSquareException.requireDiagonal(other.size()); //checks if the other matrix is a square</span>
<span class="nc" id="L200">        InconsistentSizeException.requireMatchingSize(this, other); //checks if the matrixes are of equal size</span>

<span class="nc" id="L202">        int length = this.size().row(); //sets the length of the matrixes by accessing the row of the size of this index (can be row or column from either matrix)</span>
<span class="nc" id="L203">        return instance(this.size(), this.ring, (index) -&gt; { //creates an instance of a matrix containing the product</span>

<span class="nc" id="L205">            return getProductAtIndex(other, ring, length, index);</span>
        });
        
    }

    /**
     * a subroutine which conducts multiplication and computes the resulting value at each index of the matrix
     * @param other
     * @param ring
     * @param length
     * @param index
     * @return
     */
    private T getProductAtIndex(Matrix&lt;T&gt; other, Ring&lt;T&gt; ring, int length, Indexes index) {
    
<span class="nc" id="L220">        List&lt;T&gt; products = new ArrayList&lt;&gt;();</span>
        //indexes until length is reached and adds to the product list the element at the row of this and column of other
<span class="nc bnc" id="L222" title="All 2 branches missed.">        for (int i = 0; i &lt;= length; i++) {</span>
<span class="nc" id="L223">            products.add(ring.product(this.value(new Indexes(index.row(), i)), other.value(new Indexes(i, index.column()))));</span>
        }
<span class="nc" id="L225">        return Rings.sum(products, ring); //sums the elements of the product list</span>
    }

    /**
     * a method to override the toString method
     */
    @Override
    public String toString() {

<span class="nc" id="L234">        Indexes size = size();</span>
<span class="nc" id="L235">        int numRows = size.row() + 1; // Add 1 to include row 0</span>
<span class="nc" id="L236">        int numCols = size.column() + 1; // Add 1 to include column 0</span>
    
<span class="nc" id="L238">        StringBuilder sb = new StringBuilder();</span>
        //indexing through the rows
<span class="nc bnc" id="L240" title="All 2 branches missed.">        for (int row = 0; row &lt; numRows; row++) {</span>

            //indexing through the corresponding column
<span class="nc bnc" id="L243" title="All 2 branches missed.">            for (int col = 0; col &lt; numCols; col++) {</span>
<span class="nc" id="L244">                Indexes index = new Indexes(row, col); //creating an index</span>
<span class="nc" id="L245">                T value = value(index); //finding the value at this index</span>

<span class="nc bnc" id="L247" title="All 2 branches missed.">                if (value != this.ring.zero()) {</span>
<span class="nc" id="L248">                    sb.append(&quot;[&quot;).append(index.toString()).append(&quot;]: &quot;).append(value).append(&quot;\t&quot;); //add the entry</span>
                } else {
<span class="nc" id="L250">                    sb.append(&quot;          &quot;).append(&quot;\t&quot;);</span>
                }
            }
<span class="nc" id="L253">            sb.append(&quot;\n&quot;); //add a carriage return</span>
        }
<span class="nc" id="L255">        return sb.toString();</span>
    }

    /**
     * a method to convert this matrix to a standard matrix
     * @param ring
     * @return
     */
    public MatrixMap&lt;T&gt; convertToStandard(Ring&lt;T&gt; ring) {
        
<span class="nc" id="L265">        return MatrixMap.instance(size(), (index) -&gt; {</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">            return (!matrix.containsKey(index) ? ring.zero() : value(index));</span>
        });
    }

    public static void main(String[] args) {
        
<span class="nc" id="L272">        Ring&lt;Integer&gt; ring = new IntegerRing();</span>
<span class="nc" id="L273">        Matrix&lt;Integer&gt; sparse = SparseMatrixMap.instance(2, 2, ring, (index) -&gt; (index.row()));</span>
<span class="nc" id="L274">        System.out.println(&quot;s1: \n&quot; + sparse);</span>
<span class="nc" id="L275">        Matrix&lt;Integer&gt; sparse2 = SparseMatrixMap.instance(2, 2, ring, (index) -&gt; (index.column()));</span>
<span class="nc" id="L276">        System.out.println(&quot;s2: \n&quot; + sparse2);</span>

<span class="nc" id="L278">        sparse = SparseMatrixMap.constant(2, ring, 1);</span>
        //System.out.println(sparse);

<span class="nc" id="L281">        sparse = SparseMatrixMap.identity(2, ring);</span>

        //System.out.println(SparseMatrixMap.instance(2, 2, ring, (index) -&gt; (index.column())));
        //System.out.println(SparseMatrixMap.instance(2, 2, ring, (index) -&gt; (index.column())).convertToStandard(ring));
        //System.out.println(MatrixMap.instance(2, 2, (index) -&gt; (index.column())).convertToSparse(ring));

<span class="nc" id="L287">        Matrix&lt;Integer&gt; s1 = SparseMatrixMap.instance(new Indexes(2, 2), ring, (index) -&gt; index.row());</span>
<span class="nc" id="L288">        Matrix&lt;Integer&gt; s2 = SparseMatrixMap.instance(new Indexes(2, 2), ring, (index) -&gt; index.column());</span>

<span class="nc" id="L290">        Matrix&lt;Integer&gt; m1 = MatrixMap.instance(new Indexes(2, 2), (index) -&gt; index.row());</span>
<span class="nc" id="L291">        Matrix&lt;Integer&gt; m2 = MatrixMap.instance(new Indexes(2, 2), (index) -&gt; index.column());</span>

        //TODO make plus and times methods more efficient and implement
<span class="nc" id="L294">        System.out.println(s1.plus(s2, (x, y) -&gt; ring.sum(x, y)));</span>
        //System.out.println(m1.times(m2, ring));
<span class="nc" id="L296">        System.out.println(s1.times(s2, ring));</span>
        //System.out.println(s1.value(new Indexes(0, 0)));
<span class="nc" id="L298">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>